module Abbath where

minusindexAux :: Int -> [Int]
minusindexAux 0 = []
minusindexAux n = n - 1 : minusindexAux (n-1)


minusindex :: [Int] -> [Int]
minusindex [] = []
minusindex lst = map (\(x, y) -> x - y) zipped where 
    zipped = zip (reverse lst) (minusindexAux (length lst))

-- reverse lst generates the reverse of a list [4, 3, 2 , 1]
-- minusindexAux generates a list of indices [3, 2, 1, 0]
-- zipped is the name we give to the list generated by line 19
-- zip takes the reversed list and index list and generates a
-- list of pairs like this: (4, 3), (3, 2), (2, 1), (1, 0)
-- which we call 'zipped'. We then map the lambda function
-- 'f((x,y)) = x - y' to each element of zipped and we end up
-- with [4-3, 3-2, 2-1, 1-0] which is
-- [1, 1, 1, 1] if you call it like this

-- minusindex [1, 2, 3, 4]

index :: [Char] -> Char -> Int
index [] _ = error "Character not found."
index (x:xs) y = if x == y
    then 1
    else 1 + index xs y

firstn :: [t] -> Int -> [t]
firstn [] _ = []
firstn _ 0 = []
firstn (x:xs) n = x : firstn xs (n-1)


lastn :: [t] -> Int -> [t]
lastn [] _ = []
lastn _ 0 = []
lastn  (h:t) n = if length (h:t) <= n
    then h:t
    else lastn t n